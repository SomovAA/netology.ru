Есть жизненные циклы продукта:
- Со стороны бизнеса. В которых могут принимать участие продажники, юристы, бухгалтерия, рисковики и т.д. И для каждого из них выстроены определенные процессы.
- Самих программ со стороны разработчиков. Они в большинстве случаев зависят от того, какие инструменты/framework-и используются, какие виды архитектур, и в какой последовательности происходят вызовы.
- Со стороны devops-ов...
- Со стороны менеджеров...
- ...

Весь продукт - это перемешка из всех этих циклов, которая имеет определенную форму для удобной работы с этим для определенных групп лиц, для удобного контроля, и выстраивания процессов в целом.

Рассмотрим решение этой задачи в контексте, ограниченном под: менеджера, разработчиков, тестировщиков, и DevOps-инженера.
Причем рассмотрим таким образом, когда масштабирование, основанное на количестве людей, не будет влиять на это.

Т.к. DevOps это тот, кто стоит на стыке между разработчиками, тестировщиками, системными администраторами, безопасниками...
Значит он является тем звеном, которое влияет на их всех, т.е. он будет придумывать контракты совместно с ними, и требовать/контролировать их выполнение.

Контракты с разработчиками:
- Одинаковые среды/инструменты/технологии/ide...
  Например можно собрать образы минимального размера, безопасные, определенных версий...
  И разработчики должны разворачивать проект, используя их, как основу.
  В некоторых моментах для этого придется использовать виртуализацию/контейнеризацию.
- Тесты определенных видов и автоматические.
  Причем некоторые виды могут взять на себя QA. Тут должны QA с разработчиками договариваться.
  Но девопсы могут требовать выводить в определенном формате значения покрытия кода, если они сами не разрабатывают, то
  это позволит хотя бы понимать какова ситуация в целом на поверхностном уровне. И встроить это в pipleline.
  Сюда могут включаться и анализаторы кода.
- Оптимизация образов, сборок, pipeline, deploy...
  Это влияет на скорость разработки, и доставки приложения до конечных пользователей.
  Это должно быть быстрыми. В идеале разработчики должны это уметь делать под руководством devops-ов.
- Безопасность.
  Контроль библиотек на наличие уязвимостей.
  Механизмы авторизации как в одном приложении, так и при взаимодействии между многими.
- Разные виды окружений.
  local, test, review, stage, prod...
  Для разных окружений могут использоваться разные реализации и настройки.
  Например тесты могут идти с заглушками для внешних интеграций. А на самом stage доступы могут быть до других stage, вместо заглушек.
  Некоторые из этих окружений должны создаваться/удаляться автоматически. Первый проход могут настроить devops, но дальше управлять этим могут разработчики.
  Например появился новый сервис, новые env для него и виды реализаций. Уже сам разработчик может донастроить всё, идя по пройденному пути, но всегда бывают нюансы.
  Переход из одного окружения в другой может быть настроен с использованием некоторых правил, чтобы не получилось такого, что тесты не прошли, а мы залили на prod сломанный проект.
- Мониторинг.
  Настройка логирования при определенных ситуациях, в определенных форматах и в определенные места, где всё это удобно просматривать.
  Например логи должны идти в stdout, быть в json формате, и собираться при помощи fluentid, отправляться в elk.
  Автоматическое оповещение при критических ситуациях.

Контракты с безопасниками:
- Настройка доступов сотруднику на все сервисы компании. С легким его добавлением/удалением.

Контракты с QA:
- Обсуждение инструментов тестирования, и их установка и настройка.
  Это может быть выполнено для конкретной среды, например для stage.

Контракты с юристами:
- Порой хранение данных не в нужной локации ведет к судебным разбирательствам.
- Либо хранение данных не по правилам.

Со стороны devops:
- Выбор технологий и лицензирование, покупка.
- Выбор инфраструктуры, нацеленный на оптимизацию, отказоустойчивость, экономию денег, поддержку.
- Необходима настройка всего придуманного пути, а далее помощь, контроль.
- Мониторинг.
  То, что выходит за рамки разработчиков.
  Это может быть мониторинг системы, сколько места осталось, сколько ЦП используется, оперативы...
  Это может быть мониторинг технологий. Например rabbitmq, сколько ресурсов потребляет, какие места перегружены, как внутренние взаимодействия происходят например в кластере и т.п.

Алгоритм решение задачи:
1) Сбор требований с пониманием, а нужна ли нам вообще эта задача.
   Для этого обычно есть некоторые данные/метрики, из которых вытекает потребность в этой задаче.
   Порой анализ конкрурентов/анализ отзывов/идеи бизнеса и т.п.
   В общем всё необходимое, что может понадобиться для оценки.
2) Планирование.
   Необходимо понять сколько это займет времени, какие нужны для этого ресурсы, какие шаги и кто должен сделать, также важно выбрать приоритетность задачи.
   Для этого можно декомпозировать задачу на более мелкие для более качественной оценки.
   Выявить зависимости, блокирующие факторы...и выстроить задачи таким образом, чтобы была параллельность, если это возможно.
   Перед тем, как брать задачи в работу, участники должны их просмотреть, и получить ответы на вопросы, если таковые имеются. Оценить их.
3) Работа.
   Все участники выполняют свою работу.
4) Контроль.
   Происходит контроль выполнения задач.
   Причем он может быть не только в момент закрытия задачи, но и в процессе её выполнения.
5) Анализ.
   Разбор взлетов и падений, который может изменить стратегию/подходы.

Весь этот алгоритм может быть модифицирован в зависимости от методологии...где-то он может быть ограничен по времени (1-2 недели), где-то задачами, где-то другими условными единицами.
Также для улучшения/ускорения могут быть доп. встречи ежедневные, могут быть события мотивационные, могут быть доп. обучения и прочее...

Для бизнеса в лице менеджера может использоваться специальное ПО, например jira, в которой может быть настроен flow, по которому идет задача.
to do -> in progress -> code review -> qa -> waiting release -> release -> close
code review -> in progress
qa -> in progress
