# Домашнее задание к занятию "5.2. Применение принципов IaaC в работе с виртуальными машинами"

## Задача 1
- Опишите своими словами основные преимущества применения на практике IaaC паттернов.

Чем больше автоматизации и при этом меньше шансов допустить ошибки, тем лучше. 

Если можно выстроить процессы таким образом, чтобы минимум повторных действий совершать, 
чтобы легко масштабировалось, максимальная доступность, безопасность, производительность...чтобы легко разворачивались разные окружения (dev, test, stage, prod...), и при этом всем 
есть четкие границы этих этапов, четкие абстракции с набором параметров и действий, это сплошные преимущества. 

Т.к. процессы выстраиваются последовательным образом, а последний из них работает непосредственно с prod окружением, то шансов вызвать проблемы на prod намного меньше, т.к. они выявятся на предыдущих стадиях.
По моему мнению и опыту, есть нюансы, когда и на prod косяки происходят и даже предыдущие успешно пройденные этапы не помогают...Так что все это больше похоже на стремление к идеалу, а не идеальное решение, т.к. оно зависит от огромного количества факторов, ситуаций, которые практически невозможно подогнать под единое решение (например из-за разницы в ресурсах на prod и на других окружениях, запросы могут отработать по-разному...т.е. автоматизировать все невозможно, нужны dba и другие ребята, и ручные проверки и режимы).

- Какой из принципов IaaC является основополагающим?

Как и в поговорке 'семь раз отмерь, один раз отрежь', как и в книге Исходный код, чем раньше мы проектируем правильным образом, чем раньше мы находим ошибки как в самом коде, как в архитектуре, как в самих идеях...чем этот этап происходит раньше, тем лучше для всех остальных этапов.
Это экономит огромное количество ресурсов как финансовых, так и человеческих для компании.
Если рассматривать CI, CD, CD, то первый из них CI, т.к. это раннее выявление дефектов. 

Если речь идет в целом про весь IaaC, то я бы выбрал идемпотентность, и топил бы за устранение границ между разработкой и devops (созданием сред).
Т.к. невозможно разделить разработку и развертывание в разных средах друг от друга полностью, разработчики и devops должны вместе участвовать в этих процессах.
Т.е. есть общая зона, можно сформировать контракты. Например, 12 факторов должны выполняться + ещё некоторые, если в самом проекте храним ключи, то для каких-то сред они в обычном виде, для каких-то в зашифрованном и т.д. 


## Задача 2

- Чем Ansible выгодно отличается от других систем управление конфигурациями?

Обычно во всех ОС есть ssh, ansible работает с ним, не требуя PKI.

Есть набор простых инструкций для выполнения разных задач, причем не нужно велосипед изобретать, 
реализация задач выполнена качественно, с продумыванием всевозможных нюансов, которые нам пришлось бы допиливать самим, если бы делали с нуля сами.

Я так понял это бесплатное ПО с огромным сообществом и множеством расширений/модулей.

- Какой, на ваш взгляд, метод работы систем конфигурации более надёжный push или pull?

Я думаю зависит от конкретной задачи, но я бы выбрал ручной контроль, т.е. push.
Это также позволяет сделать установку, как только изменения пришли.
А pull будет срабатывать через некоторый интервал, либо триггеры, запрашивая изменения, которые уже какое-то время лежат...

Если есть какое-то централизованное управление всеми системами, то с этим удобнее жить,
нежели каждую систему отдельно настраивать и контролировать.

## Задача 3

Установить на личный компьютер:

- VirtualBox

PS D:\Program Files\Oracle\VirtualBox> .\VBoxManage.exe -v

6.1.34r150636
- Vagrant

PS D:\Program Files\HashiCorp\Vagrant\bin> .\vagrant.exe -v

Vagrant 2.2.19
- Ansible

Танцы с бубном для windows через Cygwin64 Terminal

$ ansible --version

ansible 2.8.4
  config file = /etc/ansible/ansible.cfg
  configured module search path = ['/home/hiten/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python3.7/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 3.7.12 (default, Nov 23 2021, 18:58:07) [GCC 11.2.0]
